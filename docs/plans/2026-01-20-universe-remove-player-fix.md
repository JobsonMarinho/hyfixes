# Universe.removePlayer() Fallback Cleanup Fix

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Fix 20GB+ memory leak caused by incomplete player cleanup when `IllegalStateException` occurs during player removal.

**Architecture:** Create ASM bytecode transformer that wraps the async player removal in `Universe.removePlayer()` with try-catch, performing fallback cleanup (ChunkTracker.clear(), PacketHandler.disconnect()) when the normal path fails.

**Tech Stack:** Java 25, ASM 9, Hytale Early Plugin System

---

## ðŸ“‹ Background

**Issue:** [GitHub #34](https://github.com/John-Willikers/hyfixes/issues/34)

**The Problem:**
```java
// Universe.removePlayer() async block:
CompletableFuture.runAsync(() -> {
    Player playerComponent = ref.getStore().getComponent(ref, Player.getComponentType());  // THROWS!
    if (playerComponent != null) {
        playerComponent.remove();  // NEVER RUNS - cleanup cascade skipped!
    }
}, world)
```

**Memory Leak Cause:** When `IllegalStateException: Invalid entity reference!` is thrown:
1. `playerComponent.remove()` never executes
2. ChunkTracker still holds all loaded chunk references (HLongSet with potentially thousands of entries)
3. 20GB+ memory leak over time

**The Fix:** Catch the exception and perform fallback cleanup:
- `playerRef.getChunkTracker().clear()` - releases chunk memory
- `playerRef.getPacketHandler().disconnect()` - closes connection
- `finalizePlayerRemoval()` still runs via whenComplete handler

---

## ðŸ”§ Task 1: Add Config Toggle

**Files:**
- Modify: `hyfixes-early/src/main/java/com/hyfixes/early/config/EarlyPluginConfig.java`
- Modify: `hyfixes-early/src/main/java/com/hyfixes/early/config/EarlyConfigManager.java`
- Modify: `src/main/java/com/hyfixes/config/HyFixesConfig.java`

Add `universeRemovePlayer` toggle (default true) to TransformersConfig.

**Commit:** `feat(config): add universeRemovePlayer transformer toggle`

---

## ðŸ”§ Task 2: Create UniverseTransformer

**File:** `hyfixes-early/src/main/java/com/hyfixes/early/UniverseTransformer.java`

```java
package com.hyfixes.early;

import com.hyfixes.early.config.EarlyConfigManager;
import com.hypixel.hytale.plugin.early.ClassTransformer;
import org.objectweb.asm.ClassReader;
import org.objectweb.asm.ClassWriter;

/**
 * Transformer for Universe class to fix memory leak in removePlayer().
 *
 * When a player times out, the async removal can fail with IllegalStateException
 * if the entity reference is invalidated before getComponent() is called.
 * This leaves ChunkTracker data in memory (20GB+ leak).
 *
 * We wrap the async block with try-catch and perform fallback cleanup.
 *
 * @see <a href="https://github.com/John-Willikers/hyfixes/issues/34">GitHub Issue #34</a>
 */
public class UniverseTransformer implements ClassTransformer {

    private static final String TARGET_CLASS = "com.hypixel.hytale.server.core.universe.Universe";

    @Override
    public int priority() {
        return 100;
    }

    @Override
    public byte[] transform(String className, String packageName, byte[] classBytes) {
        if (!className.equals(TARGET_CLASS)) {
            return classBytes;
        }

        if (!EarlyConfigManager.getInstance().isTransformerEnabled("universeRemovePlayer")) {
            System.out.println("[HyFixes-Early] UniverseTransformer is disabled, skipping");
            return classBytes;
        }

        try {
            System.out.println("[HyFixes-Early] Transforming: " + TARGET_CLASS);
            System.out.println("[HyFixes-Early] Fixing removePlayer() memory leak (Issue #34)");

            ClassReader reader = new ClassReader(classBytes);
            ClassWriter writer = new ClassWriter(reader, ClassWriter.COMPUTE_FRAMES | ClassWriter.COMPUTE_MAXS);

            UniverseVisitor visitor = new UniverseVisitor(writer);
            reader.accept(visitor, ClassReader.EXPAND_FRAMES);

            if (visitor.isTransformed()) {
                System.out.println("[HyFixes-Early] Successfully transformed Universe.removePlayer()");
                return writer.toByteArray();
            } else {
                System.err.println("[HyFixes-Early] WARNING: Universe transformation did not apply!");
                return classBytes;
            }
        } catch (Exception e) {
            System.err.println("[HyFixes-Early] Error transforming Universe: " + e.getMessage());
            e.printStackTrace();
            return classBytes;
        }
    }
}
```

---

## ðŸ”§ Task 3: Create UniverseVisitor

**File:** `hyfixes-early/src/main/java/com/hyfixes/early/UniverseVisitor.java`

The visitor needs to find the lambda method generated by the compiler for the async block in `removePlayer()`. Lambda methods are named like `lambda$removePlayer$0`.

```java
package com.hyfixes.early;

import org.objectweb.asm.ClassVisitor;
import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.Opcodes;

/**
 * ASM ClassVisitor for Universe class.
 * Intercepts the lambda method used in removePlayer() async block.
 */
public class UniverseVisitor extends ClassVisitor {

    private String className;
    private boolean transformed = false;

    public UniverseVisitor(ClassVisitor classVisitor) {
        super(Opcodes.ASM9, classVisitor);
    }

    @Override
    public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {
        this.className = name;
        super.visit(version, access, name, signature, superName, interfaces);
    }

    @Override
    public MethodVisitor visitMethod(int access, String name, String descriptor, String signature, String[] exceptions) {
        MethodVisitor mv = super.visitMethod(access, name, descriptor, signature, exceptions);

        // Look for lambda methods in removePlayer - they're named lambda$removePlayer$N
        // The one we want calls Store.getComponent and Player.remove
        if (name.startsWith("lambda$removePlayer$")) {
            System.out.println("[HyFixes-Early] Found lambda method: " + className + "." + name + descriptor);
            System.out.println("[HyFixes-Early] Wrapping with fallback cleanup try-catch...");
            transformed = true;
            return new RemovePlayerLambdaVisitor(mv, className, name);
        }

        return mv;
    }

    public boolean isTransformed() {
        return transformed;
    }
}
```

---

## ðŸ”§ Task 4: Create RemovePlayerLambdaVisitor

**File:** `hyfixes-early/src/main/java/com/hyfixes/early/RemovePlayerLambdaVisitor.java`

This is the complex part. We need to:
1. Wrap the entire lambda body in try-catch for IllegalStateException
2. In the catch block, perform fallback cleanup using the captured `playerRef`

The lambda captures `playerRef` as a parameter or field access. We need to:
1. Detect when `Store.getComponent()` is called
2. Wrap it in try-catch
3. In catch, call `playerRef.getChunkTracker().clear()` and disconnect

**Approach:** Wrap the ENTIRE method body in try-catch, then in catch block perform cleanup.

```java
package com.hyfixes.early;

import org.objectweb.asm.Label;
import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.Opcodes;

/**
 * ASM MethodVisitor that wraps the removePlayer lambda with fallback cleanup.
 *
 * The lambda has access to playerRef (captured variable). On IllegalStateException,
 * we perform fallback cleanup:
 * 1. playerRef.getChunkTracker().clear()
 * 2. playerRef.getPacketHandler().disconnect(...)
 */
public class RemovePlayerLambdaVisitor extends MethodVisitor {

    private final String className;
    private final String methodName;

    private final Label tryStart = new Label();
    private final Label tryEnd = new Label();
    private final Label catchHandler = new Label();
    private final Label methodEnd = new Label();

    private boolean started = false;
    private int playerRefSlot = -1;  // Will try to detect from bytecode

    public RemovePlayerLambdaVisitor(MethodVisitor methodVisitor, String className, String methodName) {
        super(Opcodes.ASM9, methodVisitor);
        this.className = className;
        this.methodName = methodName;
    }

    @Override
    public void visitCode() {
        super.visitCode();

        // Start try block at beginning of method
        mv.visitLabel(tryStart);
        started = true;
    }

    @Override
    public void visitVarInsn(int opcode, int var) {
        super.visitVarInsn(opcode, var);

        // Try to detect playerRef local variable slot
        // In lambdas, captured variables are typically in early slots
        // We'll use slot 0 or 1 as likely candidates for playerRef
        if (playerRefSlot == -1 && opcode == Opcodes.ALOAD && var <= 2) {
            playerRefSlot = var;
        }
    }

    @Override
    public void visitInsn(int opcode) {
        // Intercept RETURN to end try block
        if (started && opcode == Opcodes.RETURN) {
            mv.visitLabel(tryEnd);
            mv.visitJumpInsn(Opcodes.GOTO, methodEnd);

            // Catch handler for IllegalStateException
            mv.visitLabel(catchHandler);

            // Exception is on stack - store it temporarily
            mv.visitVarInsn(Opcodes.ASTORE, 10);  // Store exception in slot 10

            // Log warning
            mv.visitFieldInsn(Opcodes.GETSTATIC, "java/lang/System", "err", "Ljava/io/PrintStream;");
            mv.visitLdcInsn("[HyFixes] Player ref invalid during removal - performing fallback cleanup");
            mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, "java/io/PrintStream", "println", "(Ljava/lang/String;)V", false);

            // Try to get playerRef and clean up ChunkTracker
            // playerRef is captured in the lambda - try slot 0, 1, or 2
            Label cleanupTryStart = new Label();
            Label cleanupTryEnd = new Label();
            Label cleanupCatch = new Label();
            Label cleanupDone = new Label();

            mv.visitLabel(cleanupTryStart);

            // Load playerRef (try slot 1 - common for instance method lambdas)
            mv.visitVarInsn(Opcodes.ALOAD, 1);

            // Call playerRef.getChunkTracker()
            mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL,
                "com/hypixel/hytale/server/core/universe/PlayerRef",
                "getChunkTracker",
                "()Lcom/hypixel/hytale/server/core/modules/entity/player/ChunkTracker;",
                false);

            // Call chunkTracker.clear()
            mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL,
                "com/hypixel/hytale/server/core/modules/entity/player/ChunkTracker",
                "clear",
                "()V",
                false);

            // Log success
            mv.visitFieldInsn(Opcodes.GETSTATIC, "java/lang/System", "err", "Ljava/io/PrintStream;");
            mv.visitLdcInsn("[HyFixes] ChunkTracker cleared successfully");
            mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, "java/io/PrintStream", "println", "(Ljava/lang/String;)V", false);

            mv.visitLabel(cleanupTryEnd);
            mv.visitJumpInsn(Opcodes.GOTO, cleanupDone);

            // Catch any cleanup errors
            mv.visitLabel(cleanupCatch);
            mv.visitInsn(Opcodes.POP);  // Discard cleanup exception
            mv.visitFieldInsn(Opcodes.GETSTATIC, "java/lang/System", "err", "Ljava/io/PrintStream;");
            mv.visitLdcInsn("[HyFixes] Fallback cleanup failed - memory may leak");
            mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, "java/io/PrintStream", "println", "(Ljava/lang/String;)V", false);

            mv.visitLabel(cleanupDone);

            // Register cleanup try-catch
            mv.visitTryCatchBlock(cleanupTryStart, cleanupTryEnd, cleanupCatch, "java/lang/Exception");

            // Method end - normal return
            mv.visitLabel(methodEnd);
            mv.visitInsn(Opcodes.RETURN);

            // Register main try-catch block
            mv.visitTryCatchBlock(tryStart, tryEnd, catchHandler, "java/lang/IllegalStateException");

            started = false;
            return;  // Don't call super - we handled RETURN
        }

        super.visitInsn(opcode);
    }

    @Override
    public void visitMaxs(int maxStack, int maxLocals) {
        // Ensure enough stack and locals for our injected code
        super.visitMaxs(Math.max(maxStack, 4), Math.max(maxLocals, 12));
    }
}
```

---

## ðŸ”§ Task 5: Register Transformer in SPI

Add `com.hyfixes.early.UniverseTransformer` to SPI file.

---

## ðŸ”§ Task 6: Update BUGS_FIXED.md

Add Fix 25 documentation:

```markdown
---

## Fix 25: Universe.removePlayer() Memory Leak (v1.9.5)

**Bug:** Server experiences 20GB+ memory leak when players timeout due to incomplete cleanup.

**Error:**
```
java.lang.IllegalStateException: Invalid entity reference!
    at com.hypixel.hytale.component.Ref.validate(Ref.java:59)
    at com.hypixel.hytale.component.Store.__internal_getComponent(Store.java:1222)
    at Universe.lambda$removePlayer$0(Universe.java:691)
```

**Root cause:** Race condition in `Universe.removePlayer()`. When the async cleanup task runs, the entity reference may already be invalidated. The exception prevents `playerComponent.remove()` from executing, leaving ChunkTracker data in memory.

**Fix:** ASM bytecode transformer (`UniverseTransformer`) wraps the async lambda with try-catch. On `IllegalStateException`, performs fallback cleanup:
- Calls `playerRef.getChunkTracker().clear()` to release chunk memory
- Logs warning for debugging

**Configuration:**
```json
{
  "transformers": {
    "universeRemovePlayer": true
  }
}
```

**Files:**
- `UniverseTransformer.java` - Main transformer
- `UniverseVisitor.java` - Class visitor for lambda detection
- `RemovePlayerLambdaVisitor.java` - Try-catch injection with fallback cleanup

**GitHub Issue:** [#34](https://github.com/John-Willikers/hyfixes/issues/34)
```

---

## ðŸ”§ Task 7: Build and Test

```bash
./gradlew build
```

---

## âœ… Completion Checklist

- [ ] Config toggle added
- [ ] UniverseTransformer created
- [ ] UniverseVisitor created (detects lambda$removePlayer$ methods)
- [ ] RemovePlayerLambdaVisitor created (try-catch with ChunkTracker.clear() fallback)
- [ ] SPI registration
- [ ] Documentation updated
- [ ] Build passes

---

## ðŸ“ Technical Notes

**Lambda Detection:** Java compiler generates synthetic methods named `lambda$methodName$N` for lambdas. We target `lambda$removePlayer$0` (or similar).

**PlayerRef Access:** The lambda captures `playerRef` as a parameter. In synthetic lambda methods, captured variables are typically in the first few local variable slots.

**ChunkTracker.clear():** This method uses a `StampedLock` and is thread-safe. It clears both `loading` and `loaded` HLongSet collections - the main source of the memory leak.

**Why not full cleanup:** We can't call `playerRef.removeFromStore()` because it requires a valid ref. But clearing ChunkTracker addresses the main memory leak. The orphaned entity in Store is small by comparison.
